From 2e761020f1ffc69af789d6ea0d84ed1cfe833724 Mon Sep 17 00:00:00 2001
From: hglm <synapsid_on_si@yahoo.com>
Date: Fri, 24 May 2013 01:20:29 +0200
Subject: [PATCH] Implement G2D FillRect and G2D blit improvements, and
 optimize PutImage

1. Implement an area threshold for using G2D blits in sunxi_disp.c,
   currently set to 200 for 32bpp, 1000 for 16bpp.
2. In xCopyNToN, it is guaranteed that alu == GXcopy and planemask
   == FB_ALL_ONES, so no need to check for them.
3. Implement xPolyFillRect. Only the case of a drawable window, fill
   style of FillSolid, effective alu type of GXcopy, and plane mask
   of all ones is accelerated with G2D. Only uses G2D for fills of
   10000 pixels or larger in area (50000 for 16bpp). Two implementations
   of PolyFillRect are provided, one based on fbPolyFillRect and the
   other on exaPolyFillRect. The EXA-style implementation shows an
   improvement when running x11perf -rect100.
4. Add support for 16-bit fill to sunxi_disp.c and provide a 16-bit
   fill_in_three function to fill in three segments using 32-bit
   format for the middle segment.
5. Add an optimized PutImage. This does not use G2D, but shows a clear
   improvement in some off-screen to screen blits by using pixman
   instead of the default Xorg fb implementation.
6. Add the hook for xPolyFillRect and xPutimage to xCreateGC.
7. Add use_G2D flag to SunxiG2D struct that indicates whether G2D
   acceleration is enabled. This flag is used to determine whether
   G2D FillRect should be used.
8. Implement "double speed" 16bpp blits. When source and
   destination coordinates allow it, the blit is divided into up
   to three segments with the aligned middle segment being copied in
   32bpp mode.

Signed-off-by: hglm <synapsid_on_si@yahoo.com>
---
 src/fbdev.c       |    4 +-
 src/sunxi_disp.c  |  216 ++++++++++++++++++++++++++++
 src/sunxi_disp.h  |   29 ++++
 src/sunxi_x_g2d.c |  411 ++++++++++++++++++++++++++++++++++++++++++++++++++---
 src/sunxi_x_g2d.h |    3 +-
 5 files changed, 642 insertions(+), 21 deletions(-)

diff --git a/src/fbdev.c b/src/fbdev.c
index da54673..36ef523 100644
--- a/src/fbdev.c
+++ b/src/fbdev.c
@@ -886,7 +886,7 @@ FBDevScreenInit(SCREEN_INIT_ARGS_DECL)
 						strcasecmp(accelmethod, "g2d") == 0) {
 		sunxi_disp_t *disp = fPtr->sunxi_disp_private;
 		if (disp && disp->fd_g2d >= 0 &&
-		    (fPtr->SunxiG2D_private = SunxiG2D_Init(pScreen, &disp->blt2d))) {
+		    (fPtr->SunxiG2D_private = SunxiG2D_Init(pScreen, &disp->blt2d, TRUE))) {
 
 			xf86DrvMsg(pScrn->scrnIndex, X_INFO, "enabled G2D acceleration\n");
 		}
@@ -903,7 +903,7 @@ FBDevScreenInit(SCREEN_INIT_ARGS_DECL)
 	}
 
 	if (!fPtr->SunxiG2D_private && cpu_backend->cpuinfo->has_arm_neon) {
-		if ((fPtr->SunxiG2D_private = SunxiG2D_Init(pScreen, &cpu_backend->blt2d))) {
+		if ((fPtr->SunxiG2D_private = SunxiG2D_Init(pScreen, &cpu_backend->blt2d, FALSE))) {
 			xf86DrvMsg(pScrn->scrnIndex, X_INFO, "enabled NEON optimizations\n");
 		}
 	}
diff --git a/src/sunxi_disp.c b/src/sunxi_disp.c
index 559598a..0fcf66e 100644
--- a/src/sunxi_disp.c
+++ b/src/sunxi_disp.c
@@ -27,6 +27,7 @@
 #include <unistd.h>
 #include <string.h>
 #include <stdlib.h>
+#include <stdio.h>
 #include <sys/ioctl.h>
 #include <sys/mman.h>
 
@@ -427,6 +428,116 @@ int sunxi_g2d_fill_a8r8g8b8(sunxi_disp_t *disp,
     return ioctl(disp->fd_g2d, G2D_CMD_FILLRECT, &tmp);
 }
 
+/*
+ * 16-bit fill is slower than software fill, but for completeness it is
+ * implemented here. It does help CPU utilization.
+ * color is a 16-bit R5G6B5 value.
+ */
+
+int sunxi_g2d_fill_r5g6b5(sunxi_disp_t *disp,
+                            int           x,
+                            int           y,
+                            int           w,
+                            int           h,
+                            uint32_t      color)
+{
+    g2d_fillrect tmp;
+
+    if (disp->fd_g2d < 0)
+        return -1;
+
+    if (w <= 0 || h <= 0)
+        return 0;
+
+    tmp.flag                = G2D_FIL_NONE;
+    tmp.dst_image.addr[0]   = disp->framebuffer_paddr;
+    tmp.dst_image.w         = disp->xres;
+    tmp.dst_image.h         = disp->framebuffer_height;
+    tmp.dst_image.format    = G2D_FMT_RGB565;
+    tmp.dst_image.pixel_seq = G2D_SEQ_P10;
+    tmp.dst_rect.x          = x;
+    tmp.dst_rect.y          = y;
+    tmp.dst_rect.w          = w;
+    tmp.dst_rect.h          = h;
+    /* We have to convert the color to RGB888 format. */
+    tmp.color               = ((color & 0x001F) << 3) | ((color & 0x07E0) << 5) |
+                              ((color & 0xF800) << 8);
+    tmp.alpha               = 0;
+
+    return ioctl(disp->fd_g2d, G2D_CMD_FILLRECT, &tmp);
+}
+
+/*
+ * This version of 16-bit fill splits the area into a maximum three parts
+ * horizontally. The aligned, middle part is drawn using a 32-bit fill.
+ * The left and right edges, if required, are drawn with 16-bit fill.
+ */
+
+int sunxi_g2d_fill_r5g6b5_in_three(sunxi_disp_t *disp,
+                            int           x,
+                            int           y,
+                            int           w,
+                            int           h,
+                            uint32_t      color)
+{
+    g2d_fillrect tmp;
+    uint32_t color_rgb888;
+
+    if (disp->fd_g2d < 0)
+        return -1;
+
+    if (w <= 0 || h <= 0)
+        return 0;
+
+    /* Set up invariant fill parameters. */
+    tmp.flag                = G2D_FIL_NONE;
+    tmp.dst_image.addr[0]   = disp->framebuffer_paddr;
+    tmp.dst_rect.y          = y;
+    tmp.dst_image.h         = disp->framebuffer_height;
+    tmp.dst_rect.h          = h;
+    tmp.alpha               = 0;
+
+    color_rgb888 = ((color & 0x001F) << 3) | ((color & 0x07E0) << 5) |
+                   ((color & 0xF800) << 8);
+
+    if (x & 1) {
+        tmp.dst_image.w         = disp->xres;
+        tmp.dst_image.format    = G2D_FMT_RGB565;
+        tmp.dst_image.pixel_seq = G2D_SEQ_P10;
+        tmp.dst_rect.x          = x;
+        tmp.dst_rect.w          = 1;
+        tmp.color               = color_rgb888;
+        if (ioctl(disp->fd_g2d, G2D_CMD_FILLRECT, &tmp))
+            return - 1;
+        x++;
+        w--;
+    }
+    if (w >= 2) {
+        tmp.dst_image.w         = disp->xres >> 1;
+        tmp.dst_image.format    = G2D_FMT_ARGB_AYUV8888;
+        tmp.dst_image.pixel_seq = G2D_SEQ_NORMAL;
+        tmp.dst_rect.x          = x >> 1;
+        tmp.dst_rect.w          = w >> 1;
+        tmp.color               = color | (color << 16);
+        if (ioctl(disp->fd_g2d, G2D_CMD_FILLRECT, &tmp))
+            return - 1;
+        x += (w >> 1) * 2;
+        w &= 1;
+    }
+    if (w) {
+        tmp.dst_image.w         = disp->xres;
+        tmp.dst_image.format    = G2D_FMT_RGB565;
+        tmp.dst_image.pixel_seq = G2D_SEQ_P10;
+        tmp.dst_rect.x          = x;
+        tmp.dst_rect.w          = 1;
+        tmp.color               = color_rgb888;
+        if (ioctl(disp->fd_g2d, G2D_CMD_FILLRECT, &tmp))
+            return - 1;
+    }
+    return 0;
+}
+
+
 int sunxi_g2d_blit_a8r8g8b8(sunxi_disp_t *disp,
                             int           dst_x,
                             int           dst_y,
@@ -467,6 +578,94 @@ int sunxi_g2d_blit_a8r8g8b8(sunxi_disp_t *disp,
 }
 
 /*
+ * The following function implements a 16bpp blit using 32bpp mode by
+ * splitting the area into an aligned middle part (which is blit using
+ * 32bpp mode) and left and right edges if required.
+ *
+ * It assumes the parameters have already been validated by the caller.
+ * This includes the condition (src_x & 1) == (dst_x & 1), which is
+ * necessary to be able to use 32bpp mode.
+ */
+
+int sunxi_g2d_blit_r5g6b5_in_three(sunxi_disp_t *disp, uint8_t *src_bits,
+    uint8_t *dst_bits, int src_stride, int dst_stride, int src_x, int src_y,
+    int dst_x, int dst_y, int w, int h)
+{
+    g2d_blt tmp;
+
+    /* Set up the invariant blit parameters. */
+    tmp.flag                = G2D_BLT_NONE;
+    tmp.src_image.h         = src_y + h;
+    tmp.src_rect.y          = src_y;
+    tmp.src_rect.h          = h;
+    tmp.dst_image.h         = dst_y + h;
+    tmp.dst_y               = dst_y;
+    tmp.color               = 0;
+    tmp.alpha               = 0;
+
+    if (src_x & 1) {
+        tmp.src_image.addr[0]   = disp->framebuffer_paddr +
+                                  (src_bits - disp->framebuffer_addr);
+        tmp.src_image.format    = G2D_FMT_RGB565;
+        tmp.src_image.pixel_seq = G2D_SEQ_P10;
+        tmp.src_image.w         = src_stride * 2;
+        tmp.src_rect.x          = src_x;
+        tmp.src_rect.w          = 1;
+        tmp.dst_image.addr[0]   = disp->framebuffer_paddr +
+                                  (dst_bits - disp->framebuffer_addr);
+        tmp.dst_image.format    = G2D_FMT_RGB565;
+        tmp.dst_image.pixel_seq = G2D_SEQ_P10;
+        tmp.dst_image.w         = dst_stride * 2;
+        tmp.dst_x               = dst_x;
+        if (ioctl(disp->fd_g2d, G2D_CMD_BITBLT, &tmp))
+            return 0;
+        src_x++;
+        dst_x++;
+        w--;
+    }
+    if (w >= 2) {
+        int w2;
+        tmp.src_image.addr[0]   = disp->framebuffer_paddr +
+                                  (src_bits - disp->framebuffer_addr);
+        tmp.src_image.format    = G2D_FMT_ARGB_AYUV8888;
+        tmp.src_image.pixel_seq = G2D_SEQ_NORMAL;
+        tmp.src_image.w         = src_stride;
+        tmp.src_rect.x          = src_x >> 1;
+        tmp.src_rect.w          = w >> 1;
+        tmp.dst_image.addr[0]   = disp->framebuffer_paddr +
+                                  (dst_bits - disp->framebuffer_addr);
+        tmp.dst_image.format    = G2D_FMT_ARGB_AYUV8888;
+        tmp.dst_image.pixel_seq = G2D_SEQ_NORMAL;
+        tmp.dst_image.w         = dst_stride;
+        tmp.dst_x               = dst_x >> 1;
+        if (ioctl(disp->fd_g2d, G2D_CMD_BITBLT, &tmp))
+            return 0;
+        w2 = (w >> 1) * 2;
+        src_x += w2;
+        dst_x += w2;
+        w &= 1;
+    }
+    if (w) {
+        tmp.src_image.addr[0]   = disp->framebuffer_paddr +
+                                  (src_bits - disp->framebuffer_addr);
+        tmp.src_image.format    = G2D_FMT_RGB565;
+        tmp.src_image.pixel_seq = G2D_SEQ_P10;
+        tmp.src_image.w         = src_stride * 2;
+        tmp.src_rect.x          = src_x;
+        tmp.src_rect.w          = 1;
+        tmp.dst_image.addr[0]   = disp->framebuffer_paddr +
+                                  (dst_bits - disp->framebuffer_addr);
+        tmp.dst_image.format    = G2D_FMT_RGB565;
+        tmp.dst_image.pixel_seq = G2D_SEQ_P10;
+        tmp.dst_image.w         = dst_stride * 2;
+        tmp.dst_x               = dst_x;
+        if (ioctl(disp->fd_g2d, G2D_CMD_BITBLT, &tmp))
+            return 0;
+    }
+    return 1;
+}
+
+/*
  * G2D counterpart for pixman_blt (function arguments are the same with
  * only sunxi_disp_t extra argument added). Supports 16bpp (r5g6b5) and
  * 32bpp (a8r8g8b8) formats and also conversion between them.
@@ -489,6 +688,7 @@ int sunxi_g2d_blt(void               *self,
                   int                 h)
 {
     sunxi_disp_t *disp = (sunxi_disp_t *)self;
+    int blt_size_threshold;
     g2d_blt tmp;
     /*
      * Very minimal validation here. We just assume that if the begginging
@@ -505,6 +705,18 @@ int sunxi_g2d_blt(void               *self,
         return 0;
     }
 
+    /*
+     * If the area is smaller than G2D_BLT_SIZE_THRESHOLD, prefer to avoid the
+     * overhead of G2D and do a CPU blit instead. There is a special threshold
+     * for 16bpp to 16bpp copy.
+     */
+    if (src_bpp == 16 && dst_bpp == 16)
+        blt_size_threshold = G2D_BLT_SIZE_THRESHOLD_16BPP;
+    else
+        blt_size_threshold = G2D_BLT_SIZE_THRESHOLD;
+    if (w * h < blt_size_threshold)
+        return 0;
+
     if (w <= 0 || h <= 0)
         return 1;
 
@@ -515,6 +727,10 @@ int sunxi_g2d_blt(void               *self,
     if (disp->fd_g2d < 0)
         return 0;
 
+    if (src_bpp == 16 && dst_bpp == 16 && (src_x & 1) == (dst_x & 1))
+        return sunxi_g2d_blit_r5g6b5_in_three(disp, (uint8_t *)src_bits, (uint8_t *)dst_bits,
+            src_stride, dst_stride, src_x, src_y, dst_x, dst_y, w, h);
+
     if ((src_bpp != 16 && src_bpp != 32) || (dst_bpp != 16 && dst_bpp != 32))
         return 0;
 
diff --git a/src/sunxi_disp.h b/src/sunxi_disp.h
index dc3f304..f7cb2e0 100644
--- a/src/sunxi_disp.h
+++ b/src/sunxi_disp.h
@@ -103,6 +103,11 @@ int sunxi_wait_for_vsync(sunxi_disp_t *ctx);
  * Simple G2D fill and blit operations
  */
 
+/* The following constants are used in sunxi_x_g2d.c and represent */
+/* the area threshold for falling back to CPU fill. */
+#define G2D_FILL_SIZE_THRESHOLD_32BPP 10000
+#define G2D_FILL_SIZE_THRESHOLD_16BPP 50000
+
 int sunxi_g2d_fill_a8r8g8b8(sunxi_disp_t *disp,
                             int           x,
                             int           y,
@@ -110,6 +115,20 @@ int sunxi_g2d_fill_a8r8g8b8(sunxi_disp_t *disp,
                             int           h,
                             uint32_t      color);
 
+int sunxi_g2d_fill_r5g6b5(sunxi_disp_t *disp,
+                            int           x,
+                            int           y,
+                            int           w,
+                            int           h,
+                            uint32_t      color);
+
+int sunxi_g2d_fill_r5g6b5_in_three(sunxi_disp_t *disp,
+                            int           x,
+                            int           y,
+                            int           w,
+                            int           h,
+                            uint32_t      color);
+
 int sunxi_g2d_blit_a8r8g8b8(sunxi_disp_t *disp,
                             int           dst_x,
                             int           dst_y,
@@ -118,6 +137,16 @@ int sunxi_g2d_blit_a8r8g8b8(sunxi_disp_t *disp,
                             int           w,
                             int           h);
 
+int sunxi_g2d_blit_r5g6b5_in_three(sunxi_disp_t *disp, uint8_t *src_bits,
+    uint8_t *dst_bits, int src_stride, int dst_stride, int src_x, int src_y,
+    int dst_x, int dst_y, int w, int h);
+
+/* The following constant is used sunxi_disp.c and represents */
+/* the area threshold below which the sunxi_g2d_blit function will */
+/* return 0, indicating that a software blit is preferred. */
+#define G2D_BLT_SIZE_THRESHOLD 200
+#define G2D_BLT_SIZE_THRESHOLD_16BPP 1000
+
 /* G2D counterpart for pixman_blt with the support for 16bpp and 32bpp */
 int sunxi_g2d_blt(void               *disp,
                   uint32_t           *src_bits,
diff --git a/src/sunxi_x_g2d.c b/src/sunxi_x_g2d.c
index de91bbb..73f01ef 100644
--- a/src/sunxi_x_g2d.c
+++ b/src/sunxi_x_g2d.c
@@ -37,6 +37,9 @@
 
 #include "fbdev_priv.h"
 #include "sunxi_x_g2d.h"
+#include "sunxi_disp.h"
+
+#define USE_EXA_STYLE_FILLRECT
 
 /*
  * The code below is borrowed from "xserver/fb/fbwindow.c"
@@ -68,13 +71,17 @@ xCopyWindowProc(DrawablePtr pSrcDrawable,
     fbGetDrawable(pDstDrawable, dst, dstStride, dstBpp, dstXoff, dstYoff);
 
     while (nbox--) {
-        if (!private->blt2d_overlapped_blt(private->blt2d_self,
+        Bool done = FALSE;
+        int w = pbox->x2 - pbox->x1;
+        int h = pbox->y2 - pbox->y1;
+        done = private->blt2d_overlapped_blt(private->blt2d_self,
                                            (uint32_t *)src, (uint32_t *)dst,
                                            srcStride, dstStride,
                                            srcBpp, dstBpp, (pbox->x1 + dx + srcXoff),
                                            (pbox->y1 + dy + srcYoff), (pbox->x1 + dstXoff),
-                                           (pbox->y1 + dstYoff), (pbox->x2 - pbox->x1),
-                                           (pbox->y2 - pbox->y1))) {
+                                           (pbox->y1 + dstYoff), w,
+                                           h);
+        if (!done) {
             /* fallback to fbBlt */
             fbBlt(src + (pbox->y1 + dy + srcYoff) * srcStride,
                   srcStride,
@@ -82,8 +89,8 @@ xCopyWindowProc(DrawablePtr pSrcDrawable,
                   dst + (pbox->y1 + dstYoff) * dstStride,
                   dstStride,
                   (pbox->x1 + dstXoff) * dstBpp,
-                  (pbox->x2 - pbox->x1) * dstBpp,
-                  (pbox->y2 - pbox->y1),
+                  w * dstBpp,
+                  h,
                   GXcopy, FB_ALLONES, dstBpp, reverse, upsidedown);
         }
         pbox++;
@@ -134,8 +141,6 @@ xCopyNtoN(DrawablePtr pSrcDrawable,
           int dy,
           Bool reverse, Bool upsidedown, Pixel bitplane, void *closure)
 {
-    CARD8 alu = pGC ? pGC->alu : GXcopy;
-    FbBits pm = pGC ? fbGetGCPrivate(pGC)->pm : FB_ALLONES;
     FbBits *src;
     FbStride srcStride;
     int srcBpp;
@@ -152,35 +157,40 @@ xCopyNtoN(DrawablePtr pSrcDrawable,
     fbGetDrawable(pDstDrawable, dst, dstStride, dstBpp, dstXoff, dstYoff);
 
     while (nbox--) {
-        /* first try G2D */
-        Bool done = private->blt2d_overlapped_blt(
+        /* first try G2D or the optimized NEON back-end */
+        Bool done = FALSE;
+        int w = pbox->x2 - pbox->x1;
+        int h = pbox->y2 - pbox->y1;
+        done = private->blt2d_overlapped_blt(
                              private->blt2d_self,
                              (uint32_t *)src, (uint32_t *)dst,
                              srcStride, dstStride,
                              srcBpp, dstBpp, (pbox->x1 + dx + srcXoff),
                              (pbox->y1 + dy + srcYoff), (pbox->x1 + dstXoff),
-                             (pbox->y1 + dstYoff), (pbox->x2 - pbox->x1),
-                             (pbox->y2 - pbox->y1));
+                             (pbox->y1 + dstYoff), w,
+                             h);
 
         /* then pixman (NEON) */
         if (!done && !reverse && !upsidedown) {
             done = pixman_blt((uint32_t *)src, (uint32_t *)dst, srcStride, dstStride,
                  srcBpp, dstBpp, (pbox->x1 + dx + srcXoff),
                  (pbox->y1 + dy + srcYoff), (pbox->x1 + dstXoff),
-                 (pbox->y1 + dstYoff), (pbox->x2 - pbox->x1),
-                 (pbox->y2 - pbox->y1));
+                 (pbox->y1 + dstYoff), w,
+                 h);
         }
 
         /* fallback to fbBlt if other methods did not work */
         if (!done) {
+            // Due to the check in xCopyArea, it is guaranteed that pGC->alu == GXcopy
+            // and the planemask is FB_ALLONES.
             fbBlt(src + (pbox->y1 + dy + srcYoff) * srcStride,
                   srcStride,
                   (pbox->x1 + dx + srcXoff) * srcBpp,
                   dst + (pbox->y1 + dstYoff) * dstStride,
                   dstStride,
                   (pbox->x1 + dstXoff) * dstBpp,
-                  (pbox->x2 - pbox->x1) * dstBpp,
-                  (pbox->y2 - pbox->y1), alu, pm, dstBpp, reverse, upsidedown);
+                  w * dstBpp,
+                  h, GXcopy, FB_ALLONES, dstBpp, reverse, upsidedown);
         }
         pbox++;
     }
@@ -197,8 +207,7 @@ xCopyArea(DrawablePtr pSrcDrawable,
 {
     CARD8 alu = pGC ? pGC->alu : GXcopy;
     FbBits pm = pGC ? fbGetGCPrivate(pGC)->pm : FB_ALLONES;
-
-    if (pm == FB_ALLONES && alu == GXcopy && 
+    if (pm == FB_ALLONES && alu == GXcopy &&
         pSrcDrawable->bitsPerPixel == pDstDrawable->bitsPerPixel &&
         (pSrcDrawable->bitsPerPixel == 32 || pSrcDrawable->bitsPerPixel == 16))
     {
@@ -211,6 +220,363 @@ xCopyArea(DrawablePtr pSrcDrawable,
                       xIn, yIn, widthSrc, heightSrc, xOut, yOut);
 }
 
+#ifndef USE_EXA_STYLE_FILLRECT
+
+/* Adapted from fbPolyFillRect and fbFill. */
+
+static void xPolyFillRect(DrawablePtr pDrawable,
+                          GCPtr pGC,
+                          int nrect,
+                          xRectangle * prect)
+{
+    ScreenPtr pScreen;
+    ScrnInfoPtr pScrn;
+    sunxi_disp_t *disp;
+    RegionPtr pClip;
+    BoxPtr pbox;
+    BoxPtr pextent;
+    int extentX1, extentX2, extentY1, extentY2;
+    int fullX1, fullX2, fullY1, fullY2;
+    int partX1, partX2, partY1, partY2;
+    int n;
+    FbBits *dst;
+    int dstStride;
+    int dstBpp;
+    int dstXoff, dstYoff;
+    int xorg, yorg;
+    FbGCPrivPtr pPriv;
+    int fill_size_threshold;
+    Bool fallback;
+    fallback = FALSE;
+    pPriv = fbGetGCPrivate(pGC);
+    if (pDrawable->type != DRAWABLE_WINDOW || pGC->fillStyle != FillSolid)
+        fallback = TRUE;
+    else {
+        FbBits pm = pPriv->pm;
+        if (pm != FB_ALLONES || pPriv->and)
+            fallback = TRUE;
+    }
+    if (fallback) {
+        fbPolyFillRect(pDrawable, pGC, nrect, prect);
+        return;
+    }
+
+    pScreen = pDrawable->pScreen;
+    pScrn = xf86Screens[pScreen->myNum];
+    disp = SUNXI_DISP(pScrn);
+    pClip = fbGetCompositeClip(pGC);
+
+    // Note: dstXoff and dstYoff are generally zero or negative.
+    fbGetDrawable(pDrawable, dst, dstStride, dstBpp, dstXoff, dstYoff);
+
+    // It turns out we get here not only for framebuffer destinations, so
+    // we have to check whether the destination is inside the framebuffer,
+    // otherwise fall back to CPU fill.
+    if ((uint8_t *)dst < disp->framebuffer_addr || (uint8_t *)dst >= disp->framebuffer_addr
+    + disp->framebuffer_size) {
+        fbPolyFillRect(pDrawable, pGC, nrect, prect);
+        return;
+    }
+
+    xorg = pDrawable->x;
+    yorg = pDrawable->y;
+
+    if (dstBpp == 32)
+         fill_size_threshold = G2D_FILL_SIZE_THRESHOLD_32BPP;
+    else
+         fill_size_threshold = G2D_FILL_SIZE_THRESHOLD_16BPP;
+
+    pextent = REGION_EXTENTS(pGC->pScreen, pClip);
+    extentX1 = pextent->x1;
+    extentY1 = pextent->y1;
+    extentX2 = pextent->x2;
+    extentY2 = pextent->y2;
+    while (nrect--)
+    {
+        fullX1 = prect->x + xorg;
+        fullY1 = prect->y + yorg;
+        fullX2 = fullX1 + (int) prect->width;
+        fullY2 = fullY1 + (int) prect->height;
+        prect++;
+
+        if (fullX1 < extentX1)
+            fullX1 = extentX1;
+
+        if (fullY1 < extentY1)
+            fullY1 = extentY1;
+
+         if (fullX2 > extentX2)
+            fullX2 = extentX2;
+
+        if (fullY2 > extentY2)
+            fullY2 = extentY2;
+
+        if ((fullX1 >= fullX2) || (fullY1 >= fullY2))
+            continue;
+        n = REGION_NUM_RECTS (pClip);
+        if (n == 1)
+        {
+            int x ,y, w, h;
+            x = fullX1 + dstXoff;
+            y = fullY1 + dstYoff;
+            w = fullX2 - fullX1;
+            h = fullY2 - fullY1;
+            if (!pPriv->and && w * h >= fill_size_threshold) {
+                /* We have to convert the destination address to pixel coordinates. */
+                int framebuffer_offset = (uint32_t)dst - (uint32_t)disp->framebuffer_addr;
+                int screeny = framebuffer_offset / (dstStride * 4);
+                if (dstBpp == 32) {
+                    int screenx = (framebuffer_offset % (dstStride * 4)) >> 2;
+                    sunxi_g2d_fill_a8r8g8b8(disp, x + screenx, y + screeny, w, h, pPriv->xor);
+                }
+                else {
+                    int screenx = (framebuffer_offset % (dstStride * 4)) >> 1;
+                    sunxi_g2d_fill_r5g6b5_in_three(disp, x + screenx, y + screeny, w, h,
+                        pPriv->xor & 0xFFFF);
+                }
+            }
+            else {
+                if (pPriv->and || !pixman_fill((uint32_t *)dst, dstStride, dstBpp, x, y, w, h, pPriv->xor))
+                    fbSolid(dst + y * dstStride, dstStride, x * dstBpp, dstBpp, w * dstBpp, h, pPriv->and, pPriv->xor);
+            }
+        }
+        else
+        {
+            pbox = REGION_RECTS(pClip);
+            /*
+             * clip the rectangle to each box in the clip region
+             * this is logically equivalent to calling Intersect()
+             */
+            while(n--)
+            {
+                partX1 = pbox->x1;
+                if (partX1 < fullX1)
+                    partX1 = fullX1;
+                partY1 = pbox->y1;
+                if (partY1 < fullY1)
+                    partY1 = fullY1;
+                partX2 = pbox->x2;
+                if (partX2 > fullX2)
+                    partX2 = fullX2;
+                partY2 = pbox->y2;
+                if (partY2 > fullY2)
+                    partY2 = fullY2;
+
+                pbox++;
+
+                if (partX1 < partX2 && partY1 < partY2) {
+                    int w, h;
+                    int x = partX1 + dstXoff;
+                    int y = partY1 + dstYoff;
+                    w = partX2 - partX1;
+                    h = partY2 - partY1;
+                    if (!pPriv->and && w * h >= fill_size_threshold) {
+                        int framebuffer_offset = (uint32_t)dst - (uint32_t)disp->framebuffer_addr;
+                        int screeny = framebuffer_offset / (dstStride * 4);
+                        if (dstBpp == 32) {
+                            int screenx = (framebuffer_offset % (dstStride * 4)) >> 2;
+                            sunxi_g2d_fill_a8r8g8b8(disp, x + screenx, y + screeny, w, h, pPriv->xor);
+                        }
+                        else {
+                            int screenx = (framebuffer_offset % (dstStride * 4)) >> 1;
+                            sunxi_g2d_fill_r5g6b5_in_three(disp, x + screenx, y + screeny, w, h,
+                                pPriv->xor & 0xFFFF);
+                        }
+                    }
+                    else {
+                        if (pPriv->and || !pixman_fill((uint32_t *)dst, dstStride, dstBpp, x, y, w, h, pPriv->xor))
+                            fbSolid(dst + y * dstStride, dstStride, x * dstBpp, dstBpp, w * dstBpp, h, pPriv->and, pPriv->xor);
+                    }
+                }
+            }
+        }
+    }
+    fbFinishAccess(pDrawable);
+}
+
+#else
+
+/* Adapted from exa_accel.c. */
+
+static void G2DFillRect(sunxi_disp_t *disp, FbBits *dst, int dstStride, int dstBpp, int x, int y, int w, int h, Pixel pixel) {
+    /* We have to convert the destination address to pixel coordinates. */
+    int framebuffer_offset = (uint32_t)dst - (uint32_t)disp->framebuffer_addr;
+    int screeny = framebuffer_offset / (dstStride * 4);
+    if (dstBpp == 32) {
+        int screenx = (framebuffer_offset % (dstStride * 4)) >> 2;
+        sunxi_g2d_fill_a8r8g8b8(disp, x + screenx, y + screeny, w, h, pixel);
+    }
+    else {
+        int screenx = (framebuffer_offset % (dstStride * 4)) >> 1;
+        sunxi_g2d_fill_r5g6b5_in_three(disp, x + screenx, y + screeny, w, h, pixel & 0xFFFF);
+    }
+}
+
+static Bool
+xFillRegionSolid(DrawablePtr pDrawable, RegionPtr pRegion, Pixel pixel)
+{
+    ScreenPtr pScreen = pDrawable->pScreen;
+    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
+    sunxi_disp_t *disp = SUNXI_DISP(pScrn);
+    FbBits *dst;
+    int dstStride;
+    int dstBpp;
+    int dstXoff, dstYoff;
+    int xorg, yorg;
+
+    fbGetDrawable(pDrawable, dst, dstStride, dstBpp, dstXoff, dstYoff);
+    RegionTranslate(pRegion, dstXoff, dstYoff);
+    xorg = pDrawable->x;
+    yorg = pDrawable->y;
+    int fill_size_threshold;
+    if (dstBpp == 32)
+         fill_size_threshold = G2D_FILL_SIZE_THRESHOLD_32BPP;
+    else
+         fill_size_threshold = G2D_FILL_SIZE_THRESHOLD_16BPP;
+    // It turns out we get here not only for framebuffer destinations, so 
+    // we have to check whether the destination is inside the framebuffer.
+    BOOL outside_framebuffer = FALSE;
+    if ((uint8_t *)dst - disp->framebuffer_addr < 0 || (uint8_t *)dst - disp->framebuffer_addr
+    >= disp->framebuffer_size)
+       outside_framebuffer = TRUE;
+
+    int nbox;
+    BoxPtr pBox;
+    nbox = RegionNumRects(pRegion);
+    pBox = RegionRects(pRegion);
+    while (nbox--) {
+       int w = pBox->x2 - pBox->x1;
+       int h = pBox->y2 - pBox->y1;
+       if (!outside_framebuffer && w * h >= fill_size_threshold)
+           G2DFillRect(disp, dst, dstStride, dstBpp, pBox->x1, pBox->y1, w, h, pixel);
+       else {
+           if (!pixman_fill((uint32_t *)dst, dstStride, dstBpp, pBox->x1, pBox->y1, w, h, pixel))
+               fbSolid(dst + pBox->y1 * dstStride, dstStride, pBox->x1 * dstBpp, dstBpp, w * dstBpp, h, 0, pixel);
+       }
+       pBox++;
+    }
+    fbFinishAccess(pDrawable);
+}
+
+static void xPolyFillRect(DrawablePtr pDrawable,
+                          GCPtr pGC,
+                          int nrect,
+                          xRectangle * prect)
+{
+    FbGCPrivPtr pPriv;
+    pPriv = fbGetGCPrivate(pGC);
+    /*
+     * For ROPs where overlaps don't matter, convert rectangles to region and
+     * call xFillRegionSolid.
+     */
+    if (pDrawable->type == DRAWABLE_WINDOW && pGC->fillStyle == FillSolid && pPriv->pm == FB_ALLONES &&
+    !pPriv->and &&
+    (nrect == 1 || pGC->alu == GXcopy || pGC->alu == GXclear || pGC->alu == GXnoop ||
+    pGC->alu == GXcopyInverted || pGC->alu == GXset)) {
+        RegionPtr pClip = fbGetCompositeClip(pGC);
+        RegionPtr pReg = pReg = RegionFromRects(nrect, prect, CT_UNSORTED);
+        /* Compute intersection of rects and clip region */
+        RegionTranslate(pReg, pDrawable->x, pDrawable->y);
+        RegionIntersect(pReg, pClip, pReg);
+        if (RegionNumRects(pReg))
+            xFillRegionSolid(pDrawable, pReg, pPriv->xor);
+        RegionUninit(pReg);
+        RegionDestroy(pReg);
+    }
+    else
+        // Fall back.
+        fbPolyFillRect(pDrawable, pGC, nrect, prect);
+}
+
+#endif
+
+/* Adapted from fbPutImage.c. */
+
+void xPutImage(DrawablePtr pDrawable,
+           GCPtr pGC,
+           int depth,
+           int x, int y, int w, int h, int leftPad, int format, char *pImage)
+{
+    FbGCPrivPtr pPriv;
+
+    FbStride srcStride;
+    FbStip *src;
+    RegionPtr pClip;
+    FbStip *dst;
+    FbStride dstStride;
+    int dstBpp;
+    int dstXoff, dstYoff;
+    int nbox;
+    BoxPtr pbox;
+    int x1, y1, x2, y2;
+
+    if (format == XYBitmap || format == XYPixmap ||
+    pDrawable->bitsPerPixel != BitsPerPixel(pDrawable->depth)) {
+        fbPutImage(pDrawable, pGC, depth, x, y, w, h, leftPad, format, pImage);
+        return;
+    }
+
+    pPriv =fbGetGCPrivate(pGC);
+    if (pPriv->pm != FB_ALLONES || pGC->alu != GXcopy) {
+        fbPutImage(pDrawable, pGC, depth, x, y, w, h, leftPad, format, pImage);
+        return;
+    }
+
+    ScreenPtr pScreen = pDrawable->pScreen;
+    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
+    SunxiG2D *private = SUNXI_G2D(pScrn);
+
+    src = (FbStip *)pImage;
+
+    x += pDrawable->x;
+    y += pDrawable->y;
+
+    srcStride = PixmapBytePad(w, pDrawable->depth) / sizeof(FbStip);
+    pClip = fbGetCompositeClip(pGC);
+
+    fbGetStipDrawable(pDrawable, dst, dstStride, dstBpp, dstXoff, dstYoff); 
+
+    for (nbox = RegionNumRects(pClip),
+        pbox = RegionRects(pClip); nbox--; pbox++) {
+        x1 = x;
+        y1 = y;
+        x2 = x + w;
+        y2 = y + h;
+        if (x1 < pbox->x1)
+            x1 = pbox->x1;
+        if (y1 < pbox->y1)
+            y1 = pbox->y1;
+        if (x2 > pbox->x2)
+            x2 = pbox->x2;
+        if (y2 > pbox->y2)
+            y2 = pbox->y2;
+        if (x1 >= x2 || y1 >= y2)
+            continue;
+        Bool done = FALSE;
+        int w = x2 - x1;
+        int h = y2 - y1;
+        /* first try pixman (NEON) */
+        if (!done) {
+            done = pixman_blt((uint32_t *)src, (uint32_t *)dst, srcStride, dstStride,
+                 dstBpp, dstBpp, x1 - x,
+                 y1 - y, x1 + dstXoff,
+                 y1 + dstYoff, w,
+                 h);
+        }
+        if (!done)
+            fbBlt(src + (y1 - y) * srcStride,
+                  srcStride,
+                  (x1 - x) * dstBpp,
+                  dst + (y1 + dstYoff) * dstStride,
+                  dstStride,
+                  (x1 + dstXoff) * dstBpp,
+                  w * dstBpp,
+                  h, GXcopy, FB_ALLONES, dstBpp, FALSE, FALSE);
+    }
+    fbFinishAccess(pDrawable);
+}
+
+
 static Bool
 xCreateGC(GCPtr pGC)
 {
@@ -228,6 +594,11 @@ xCreateGC(GCPtr pGC)
 
         /* Add our own hook for CopyArea function */
         self->pGCOps->CopyArea = xCopyArea;
+        if (self->use_G2D)
+            /* Add our own hook for PolyFillRect */
+            self->pGCOps->PolyFillRect = xPolyFillRect;
+        /* Add our own hook for PutImage */
+        self->pGCOps->PutImage = xPutImage;
     }
     pGC->ops = self->pGCOps;
 
@@ -236,7 +607,7 @@ xCreateGC(GCPtr pGC)
 
 /*****************************************************************************/
 
-SunxiG2D *SunxiG2D_Init(ScreenPtr pScreen, blt2d_i *blt2d)
+SunxiG2D *SunxiG2D_Init(ScreenPtr pScreen, blt2d_i *blt2d, Bool use_G2D)
 {
     SunxiG2D *private = calloc(1, sizeof(SunxiG2D));
     if (!private) {
@@ -257,6 +628,10 @@ SunxiG2D *SunxiG2D_Init(ScreenPtr pScreen, blt2d_i *blt2d)
     private->CreateGC = pScreen->CreateGC;
     pScreen->CreateGC = xCreateGC;
 
+    /* Set the flag that indicates whether the G2D hardware engine */
+    /* is used. */
+    private->use_G2D = use_G2D;
+
     return private;
 }
 
diff --git a/src/sunxi_x_g2d.h b/src/sunxi_x_g2d.h
index d58e25d..048b5b4 100644
--- a/src/sunxi_x_g2d.h
+++ b/src/sunxi_x_g2d.h
@@ -47,9 +47,10 @@ typedef struct {
                                 int       dst_y,
                                 int       w,
                                 int       h);
+    BOOL use_G2D;
 } SunxiG2D;
 
-SunxiG2D *SunxiG2D_Init(ScreenPtr pScreen, blt2d_i *blt2d);
+SunxiG2D *SunxiG2D_Init(ScreenPtr pScreen, blt2d_i *blt2d, Bool use_G2D);
 void SunxiG2D_Close(ScreenPtr pScreen);
 
 #endif
-- 
1.7.10.4

