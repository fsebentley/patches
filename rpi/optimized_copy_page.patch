From 95479bb1a8ae43e00319291b233524b3afcf6607 Mon Sep 17 00:00:00 2001
From: Harm Hanemaaijer <fgenfb@yahoo.com>
Date: Thu, 20 Jun 2013 21:04:54 +0200
Subject: [PATCH 1/2] Optimize copy_page for Raspberry Pi


Signed-off-by: Harm Hanemaaijer <fgenfb@yahoo.com>
---
 arch/arm/lib/copy_page.S |   72 +++++++++++++++++++++++++++++++++++-----------
 1 file changed, 55 insertions(+), 17 deletions(-)

diff --git a/arch/arm/lib/copy_page.S b/arch/arm/lib/copy_page.S
index 6ee2f67..2d73430 100644
--- a/arch/arm/lib/copy_page.S
+++ b/arch/arm/lib/copy_page.S
@@ -14,10 +14,29 @@
 #include <asm/asm-offsets.h>
 #include <asm/cache.h>
 
-#define COPY_COUNT (PAGE_SZ / (2 * L1_CACHE_BYTES) PLD( -1 ))
+/*
+ * Notes for Raspberry Pi:
+ * RPi does not like paired preloads in a 64-byte loop. Instead,
+ * use a 32-byte loop with one preload per loop. In addition,
+ * make sure no prefetching happens beyond the source region.
+ * The prefetch distance is set to 3 (96 bytes).
+ *
+ * This version should also be usable on architectures other than
+ * armv6 with properly defined L1_CACHE_BYTES and PREFETCH_DISTANCE.
+ */
+
+
+#define PREFETCH_DISTANCE 3
+#define COPY_COUNT (PAGE_SZ / (L1_CACHE_BYTES))
+
+#if __LINUX_ARM_ARCH__ >= 5
+#define NO_PLD(code...)
+#else
+#define NO_PLD(code...)	code
+#endif
 
 		.text
-		.align	5
+		.p2align	5
 /*
  * StrongARM optimised copy_page routine
  * now 1.78bytes/cycle, was 1.60 bytes/cycle (50MHz bus -> 89MB/s)
@@ -25,23 +44,42 @@
  * the core clock switching.
  */
 ENTRY(copy_page)
-		stmfd	sp!, {r4, lr}			@	2
+		stmfd	sp!, {r4-r8, lr}		@	2
 	PLD(	pld	[r1, #0]		)
 	PLD(	pld	[r1, #L1_CACHE_BYTES]		)
+.if PREFETCH_DISTANCE > 2
+	PLD(	pld	[r1, #2 * L1_CACHE_BYTES]	)
+.if PREFETCH_DISTANCE > 3
+	PLD(	pld	[r1, #3 * L1_CACHE_BYTES]	)
+.if PREFETCH_DISTANCE > 4
+	PLD(	pld	[r1, #4 * L1_CACHE_BYTES]	)
+.endif
+.endif
+.endif
 		mov	r2, #COPY_COUNT			@	1
-		ldmia	r1!, {r3, r4, ip, lr}		@	4+1
-1:	PLD(	pld	[r1, #2 * L1_CACHE_BYTES])
-	PLD(	pld	[r1, #3 * L1_CACHE_BYTES])
+1:	PLD(	pld	[r1, #PREFETCH_DISTANCE * L1_CACHE_BYTES])
 2:
-	.rept	(2 * L1_CACHE_BYTES / 16 - 1)
-		stmia	r0!, {r3, r4, ip, lr}		@	4
-		ldmia	r1!, {r3, r4, ip, lr}		@	4
-	.endr
-		subs	r2, r2, #1			@	1
-		stmia	r0!, {r3, r4, ip, lr}		@	4
-		ldmgtia	r1!, {r3, r4, ip, lr}		@	4
-		bgt	1b				@	1
-	PLD(	ldmeqia r1!, {r3, r4, ip, lr}	)
-	PLD(	beq	2b			)
-		ldmfd	sp!, {r4, pc}			@	3
+.if L1_CACHE_BYTES == 32
+		ldmia	r1!, {r3-r6}			@	4+1
+	PLD(	sub	r2, r2, #1		)	@	1
+	NO_PLD(	subs	r2, r2, #1		)	@	1
+		ldmia   r1!, {r7, r8, ip, lr}
+		stmia	r0!, {r3-r6}			@	4
+	PLD(	cmp	r2, #PREFETCH_DISTANCE	)
+		stmia   r0!, {r7, r8, ip, lr}
+.else /* L1_CACHE_BYTES == 64 */
+		ldmia   r1!, {r3-r8, ip, lr}
+	PLD(	sub	r2, r2, #1		)	@	1
+	NO_PLD(	subs	r2, r2, #1		)	@	1
+		stmia	r0!, {r3-r8, ip, lr}		@	4
+		ldmia   r1!, {r3-r8, ip, lr}
+	PLD(	cmp	r2, #PREFETCH_DISTANCE	)
+		stmia	r0!, {r3-r8, ip, lr}		@	4
+.endif
+	PLD(	bgt	1b			)	@	1
+	NO_PLD(	bne	1b			)
+	PLD(	teq	r2, #0			)
+	PLD(	bne	2b			)
+		ldmfd	sp!, {r4-r8, pc}		@	3
 ENDPROC(copy_page)
+
-- 
1.7.9.5

